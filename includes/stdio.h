// ----------------------------------------------------------------------------
// $Id$
// ----------------------------------------------------------------------------
// Public Domain C Library - http://pdclib.sourceforge.net
// This code is Public Domain. Use, modify, and redistribute at will.
// ----------------------------------------------------------------------------
// Input/output
// ----------------------------------------------------------------------------

#ifndef __STDIO_H
#define __STDIO_H __STDIO_H

// ----------------------------------------------------------------------------
// MACROS

#include "__NULL.h"

#define _IOFBF       // integer constant suitable as 3rd argument to setvbuf()
#define _IOLBF       // integer constant suitable as 3rd argument to setvbuf()
#define _IONBF       // integer constant suitable as 3rd argument to setvbuf()
#define BUFSIZ       // integer constant, size of the buffer used by setbuf(),
                     // >= 256
#define EOF          // TODO
#define FILENAME_MAX // length of filenames supported
#define FOPEN_MAX    // number of simultaneous open files supported, >= 8
#define L_tmpnam     // length of filenames generated by tmpnam()
#define SEEK_CUR     // integer constant suitable as 3rd argument to fseek()
#define SEEK_END     // integer constant suitable as 3rd argument to fseek()
#define SEEK_SET     // integer constant suitable as 3rd argument to fseek()
#define TMP_MAX      // number of unique filenames generateable by tmpnam(),
                     // >= 25

#define stderr // FILE*, not fully buffered
#define stdin  // FILE*, fully buffered only when not interactive device
#define stdout // FILE*, fully buffered only when not interactive device

// ----------------------------------------------------------------------------
// TYPEDEFS

#include "__size_t.h"

typedef FILE;   // object holding all stream information, including file pos,
                // buffer (optional), error indicator, EOF indicator
typedef fpos_t; // position indicator type, other than array - personality?
                // (see mbstate_t)

// ----------------------------------------------------------------------------
// FUNCTIONS

/** CLEAR ERRor. Clears EOF and error indicator of a FILE handle.
    @param fh The file handle.
 */
void clearerr( FILE * fh );

/** File CLOSE. Flush output buffers (if any) and closes the FILE handle.
    @param stream The file handle.
    @return 0 if successful, non-zero if failed. (In any case, the FILE handle 
            is invalid afterwards.)
 */
int fclose( FILE * fh );

int feof( FILE * stream );
int ferror( FILE * stream );

/** File FLUSH. Flushes output buffers (if any) for given file handle. If
    parameter is NULL, flushes output buffers for all file handles.
    @param fh The file handle.
    @return 0 if successful, EOF if failed (setting error indicators).
 */
int fflush( FILE * fh );

/** File OPEN. Opens the file specified by the given name.
    @param filename Name of the file to be opened.
    @param mode One of r, w, a, rb, wb, ab, r+, w+, a+, rb+, wb+, ab+,
           specifying which mode to open the file in.
    @return A file handle associated with the opened file, NULL if failed.
 */
FILE * fopen( const char * restrict filename, const char * restrict mode );

/** File REOPEN. Opens the file specified by the given name, associating it
    with the given file handle. If filename is NULL, it is attempted to change
    the mode of the already opened file associated with the given file handle.
    (This function can e.g. be used to reassociate stdin / stdout / stderr with
    a filename.)
    @param filename Name of the file to be opened.
    @param mode One of r, w, a, rb, wb, ab, r+, w+, a+, rb+, wb+, ab+,
           specifying which mode to open the file in.
    @param fh The file handle to associate with the opened file.
    @return fh if successful, NULL if failed.
 */
FILE * freopen( const char * restrict filename, const char * restrict mode, FILE * fh );

/** REMOVE file. Causes a file to be no longer accessible under a given name.
    If the file is currently open, this implementation of remove() fails,
    returning INT_MAX.
    @param filename Name of the file to be removed.
    @return 0 if successful, non-zero if failed. (Implementation defined:
            INT_MAX if the file is currently open.)
 */
int remove( const char * filename );

/** RENAME file. Causes a file to be no longer accessible under a given name,
    but a new name instead. If a file with the intended new name already
    exists, this implementation of rename() fails, returning INT_MAX.
    @param old Name of the file to be renamed.
    @param new Name to rename the file to.
    @return 0 if successful, non-zero if failed. (Implementation defined:
            INT_MAX if target file name already exists.)
 */
int rename( const char * old, const char * new );

void rewind( FILE * stream );

/** SET Virtual BUFfer. Sets buffering mode and (optionally) the memory used
    for buffering, for a given file handle.
    This function must only be called immediately after associating the file
    handle with a file, before any operations are called on the file handle.
    @param fh The file handle.
    @param buf A pointer to the memory area to use for buffering, or NULL to
           use internally assigned buffer memory.
    @param mode One of _IOFBF, _IOLBF, _IONBF.
    @param size Size of the memory area to be used for buffering.
 */
int setvbuf( FILE * restrict fh, char * restrict buf, int mode, size_t size );

/** SET BUFfer. Equivalent to (void) setvbuf( fh, buf, _IOFBF, BUFSIZ ), or
    (void) setvbuf( fh, NULL, _IONBF, BUFSIZ ) if buf == NULL.
    @param fh The file handle to be passed to setvbuf().
    @param buf The buffer pointer to be passed to setvbuf().
 */
void setbuf( FILE * restrict fh, char * restrict buf );

/** TeMPorary FILE. Opens a file in "wb+" mode that will be automatically
    deleted when closed, or when the program terminates.
    @return A file handle for the temporary file. (NULL if opening failed.)
 */
FILE * tmpfile( void )

/** TeMPorary NAMe. Generates a random file name that does not yet exist in the
    file system. Note that a file generated with this name is not "temporary",
    and must be remove()d normally.
    @param dest NULL, or a char[ L_tmpnam ] array.
    @return A pointer to a static internal buffer containing the file name,
            or NULL if no file name could be generated. If 'dest' is not NULL,
            writes the file name to and returns 'dest'.
 */ 
char * tmpnam( char * dest );

int fseek( FILE * stream, long offset, int mode );
int fsetpos( FILE * stream, const fpos_t * pos );
int fgetpos( FILE * restrict stream, fpos_t * restrict pos );
long ftell( FILE * stream );

int fgetc( FILE * stream );
char *fgets( char * restrict s, int n, FILE * restrict stream );
size_t fread( void * restrict ptr, size_t size, size_t nelem, FILE * restrict stream );
int getc( FILE * stream );
int getchar( void );
char * gets( char * s );
int ungetc( int c, FILE * stream );

int fputc( int c, FILE * stream );
int fputs( const char * restrict s, FILE * restrict stream );
size_t fwrite( const void * restrict ptr, size_t size, size_t nelem, FILE * restrict stream );
void perror( const char * s );
int putc( int c, FILE * stream );
int putchar( int c );
int puts( const char * s );

/** File SCAN Formatted. Reads from given file handle, under control of a
    formatting string, the values of variables pointed to by 0..n pointers.
    @param fh The file handle.
    @param format The formatting string.
    @param ... A list of 0..n pointers corresponding to placeholders in
           'format'.
    @return EOF if failed, number of values successfully assigned otherwise.
 */
int fscanf( FILE * restrict fh, const char * restrict format, ... );

/** SCAN Formatted. Equivalent to fscanf( stdin, format, ... )
    @param format The formatting string.
    @param ... A list of 0..n pointers corresponding to placeholders in
           'format'.
    @return EOF if failed, number of values successfully assigned otherwise.
 */
int scanf( const char * restrict format, ... );

/** String SCAN Formatted. Equivalent to scanf( format, ... ), but using a C
    string instead of a file handle for input.
    @param src The input string.
    @param format The formatting string.
    @param ... A list of 0..n pointers corresponding to placeholders in
           'format'.
    @return EOF if failed, number of values successfully assigned otherwise.
 */
int sscanf( const char * restrict src, const char * restrict format, ... );

/** Variable File SCAN Formatted. Equivalent to fscanf( fh, format, ... ),
    with the variable-length parameter list replaced by a va_list, created by
    the va_start macro.
    @param fh The file handle.
    @param format The formatting string.
    @param args The argument list created by the va_start macro.
    @return Number of characters printed.
 */
int vfscanf( FILE * restrict stream, const char * restrict format, va_list args );

/** Variable SCAN Formatted. Equivalent to vfscanf( stdin, format, args ).
    @param format The formatting string.
    @param args The argument list created by the va_start macro.
    @return Number of characters printed.
 */
int vscanf( const char * restrict format, va_list args );

/** Variable String SCAN Formatted. Equivalent to vscanf( format, args ), but
    reading from a C string instead of stdin.
    @param src The C string to read from.
    @param format The formatting string.
    @param args The argument list created by the va_start macro.
    @return Number of characters printed.
 */
int vsscanf( const char * restrict src, const char * restrict format, va_list ap );

/** File PRINT Formatted. Prints to given file handle, under control of a
    formatting string, the values of 0..n variables.
    @param fh The file handle.
    @param format The formatting string.
    @param ... A list of 0..n variables corresponding to placeholders in
           'format'.
    @return Number of characters printed, negative value if error occurred.
 */
int fprintf( FILE * restrict stream, const char * restrict format, ... );

/** PRINT Formatted. Equivalent to fprintf( stdout, format, ... ).
    @param format The formatting string.
    @param ... A list of 0..n variables corresponding to placeholders in
           'format'.
    @return Number of characters printed.
 */
int printf( const char * restrict format, ... );

/** String N PRINT Formatted. Equivalent to sprintf( dest, format, ... ), but
    will not write more than n characters.
    @param dest The char array to write to.
    @param n The maximum number of characters to write.
    @param format The formatting string.
    @param ... A list of 0..n variables corresponding to placeholders in
           'format'.
    @return Number of characters printed.
 */
int snprintf( char * restrict s, size_t n, const char * restrict format, ... );

/** String PRINT Formatted. Equivalent to printf( format, ... ), but writing
    to a char array instead of stdout.
    @param dest The char array to write to.
    @param format The formatting string.
    @param ... A list of 0..n variables corresponding to placeholders in
           'format'.
    @return Number of characters printed.
 */
int sprintf( char * restrict dest, const char * restrict format, ... );

/** Variable File PRINT Formatted. Equivalent to fprintf( fh, format, ... ),
    with the variable-length parameter list replaced by a va_list, created by
    the va_start macro.
    @param fh The file handle.
    @param format The formatting string.
    @param args The argument list created by the va_start macro.
    @return Number of characters printed.
 */
int vfprintf( FILE * restrict fh, const char * restrict format, va_list args );

/** Variable PRINT Formatted. Equivalent to vfprintf( stdout, format, args ).
    @param format The formatting string.
    @param args The argument list created by the va_start macro.
    @return Number of characters printed.
 */
int vprintf( const char * restrict format, va_list args );

/** Variable String N PRINT Formatted. Equivalent to vsprintf( dest, format,
    args ), but will not write more than n characters.
    @param dest The char array to write to.
    @param n Maximum number of characters to write.
    @param format The formatting string.
    @param args The argument list created by the va_start macro.
    @return Number of characters printed.
 */
int vsnprintf( char * restrict dest, size_t n, const char * restrict format, va_list ap );

/** Variable String PRINT Formatted. Equivalent to vprintf( format, args ), but
    writing to a char array instead to stdout.
    @param dest The char array to write to.
    @param format The formatting string.
    @param args The argument list created by the va_start macro.
    @return Number of characters printed.
 */
int vsprintf( char * restrict s, const char * restrict format, va_list ap);

/* PDPC code - unreviewed
/*
    What we have is an internal buffer, which is 8 characters
    longer than the actually used buffer.  E.g. say BUFSIZ is
    512 bytes, then we actually allocate 520 bytes.  The first
    2 characters will be junk, the next 2 characters set to NUL,
    for protection against some backward-compares.  The fourth-last
    character is set to '\n', to protect against overscan.  The
    last 3 characters will be junk, to protect against memory
    violation.  intBuffer is the internal buffer, but everyone refers
    to fbuf, which is actually set to the &intBuffer[4].  Also,
    szfbuf is the size of the "visible" buffer, not the internal
    buffer.  The reason for the 2 junk characters at the beginning
    is to align the buffer on a 4-byte boundary.
*/

typedef struct
{
#if (defined(__OS2__) || defined(__32BIT__))
    unsigned long hfile;  /* OS/2 file handle */
#endif
#if (defined(__MSDOS__) || defined(__DOS__) || defined(__POWERC))
    int hfile; /* dos file handle */
#endif
#if (defined(__MVS__))
    void *hfile;
    int recfm;
    int style;
    int lrecl;
    char ddname[9];
#endif
    int quickBin;  /* 1 = do DosRead NOW!!!! */
    int quickText; /* 1 = quick text mode */
    int textMode; /* 1 = text mode, 0 = binary mode */
    int intFno;   /* internal file number */
    unsigned long bufStartR; /* buffer start represents, e.g. if we
        have read in 3 buffers, each of 512 bytes, and we are
        currently reading from the 3rd buffer, then the first
        character in the buffer would be 1024, so that is what is
        put in bufStartR. */
    char *fbuf;     /* file buffer - this is what all the routines
                       look at. */
    size_t szfbuf;  /* size of file buffer (the one that the routines
                       see, and the user allocates, and what is actually
                       read in from disk) */
    char *upto;     /* what character is next to read from buffer */
    char *endbuf;   /* pointer PAST last character in buffer, ie it
                       points to the '\n' in the internal buffer */
    int errorInd;   /* whether an error has occurred on this file */
    int eofInd;     /* whether EOF has been reached on this file */
    int ungetCh;    /* character pushed back, -1 if none */
    int bufTech;    /* buffering technique, _IOFBF etc */
    char *intBuffer; /* internal buffer */
    int noNl;       /* When doing gets, we don't copy NL */
    int mode;       /* __WRITE_MODE or __READ_MODE */
    int update;     /* Is file update (read + write)? */
    int theirBuffer; /* Is the buffer supplied by them? */
} FILE;

typedef unsigned long fpos_t;

#define NULL ((void *)0)
#define FILENAME_MAX 260
#define FOPEN_MAX 40
#define _IOFBF 1
#define _IOLBF 2
#define _IONBF 3
/*#define BUFSIZ 409600*/
/* #define BUFSIZ 8192 */
/*#define BUFSIZ 5120*/
#define BUFSIZ 6144
/* #define BUFSIZ 10 */
/* #define BUFSIZ 512 */
#define EOF -1
#define L_tmpnam FILENAME_MAX
#define TMP_MAX 25
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#define __NFILE (FOPEN_MAX - 3)
#define __WRITE_MODE 1
#define __READ_MODE 2

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;

extern FILE *__userFiles[__NFILE];
*/

#endif // __STDIO_H
